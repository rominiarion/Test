<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Block Zen: Ultra Precision</title>
    <style>
        :root {
            --bg-color: #0b0c10;
            --grid-bg: #1f2833;
            --cell-empty: #2c3540;
            --accent: #66fcf1;
            --accent-dim: #45a29e;
            --text-primary: #ffffff;
            --text-secondary: #c5c6c7;
            --gold: #ffd700;
            --danger: #ff4b4b;
            --c1: #f39c12; --c2: #e74c3c; --c3: #8e44ad; --c4: #3498db; --c5: #2ecc71; 
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; font-family: 'Segoe UI', sans-serif; }

        body {
            margin: 0; background-color: var(--bg-color); color: var(--text-primary);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; overflow: hidden;
        }

        .header {
            width: 100%; max-width: 450px; display: flex; justify-content: space-between;
            padding: 15px 20px; background: rgba(31, 40, 51, 0.95); position: fixed;
            top: 0; z-index: 100; border-bottom: 1px solid rgba(102, 252, 241, 0.1);
        }
        .stat-group { display: flex; flex-direction: column; }
        .stat-label { font-size: 0.7rem; color: var(--text-secondary); text-transform: uppercase; }
        .stat-value { font-size: 1.4rem; font-weight: 800; }
        .coin-display { color: var(--gold); display: flex; align-items: center; gap: 4px; }

        .game-wrapper { margin-top: 60px; display: flex; flex-direction: column; align-items: center; width: 100%; }
        
        .grid-container {
            width: 92vw; max-width: 380px; aspect-ratio: 1; background: var(--grid-bg);
            border-radius: 8px; padding: 6px; display: grid;
            grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
            gap: 4px; box-shadow: 0 0 40px rgba(0,0,0,0.7); position: relative;
        }
        .cell { background-color: var(--cell-empty); border-radius: 4px; transition: 0.1s; }
        .cell.ghost { background-color: rgba(255, 255, 255, 0.3) !important; border: 2px solid #fff; z-index: 2; }
        .cell.filled { box-shadow: inset 0 0 8px rgba(0,0,0,0.4); }

        .powerup-bar { width: 92vw; max-width: 380px; display: flex; justify-content: space-between; margin: 15px 0; }
        .power-btn {
            background: var(--grid-bg); border: 1px solid var(--accent-dim); color: var(--accent);
            border-radius: 8px; width: 31%; height: 50px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; font-weight: bold; cursor: pointer;
        }
        .power-btn:disabled { opacity: 0.2; }
        .power-btn.active-mode { background: var(--accent); color: var(--bg-color); box-shadow: 0 0 15px var(--accent); }
        .power-btn span { font-size: 0.55rem; }

        .dock { width: 100%; max-width: 450px; height: 130px; display: flex; justify-content: space-around; align-items: center; }
        
        /* Slot alanını genişlettik ki blok kolayca tutulsun */
        .slot { 
            width: 32%; height: 100%; display: flex; justify-content: center; 
            align-items: center; background: rgba(255,255,255,0.02); border-radius: 10px;
            cursor: pointer;
        }

        .shape-preview { display: grid; gap: 2px; pointer-events: none; }
        .shape-block { width: 22px; height: 22px; border-radius: 3px; }
        
        .shape-preview.dragging {
            position: fixed; z-index: 9999; pointer-events: none; opacity: 1; gap: 4px;
        }
        .shape-preview.dragging .shape-block {
            width: var(--drag-size); height: var(--drag-size);
        }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 12, 16, 0.98); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 5000; opacity: 0;
            pointer-events: none; transition: opacity 0.3s;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        .btn-restart { margin-top: 20px; padding: 15px 40px; background: var(--accent); border: none; border-radius: 50px; font-weight: bold; color: var(--bg-color); }
    </style>
</head>
<body>

    <div class="header">
        <div class="stat-group"><span class="stat-label">Puan</span><span class="stat-value" id="uiScore">0</span></div>
        <div class="stat-group" style="align-items: flex-end;">
            <span class="stat-label">Cüzdan</span>
            <div class="stat-value coin-display"><span id="uiCoins">0</span><span>●</span></div>
        </div>
    </div>

    <div class="game-wrapper">
        <div class="grid-container" id="grid"></div>
        <div class="powerup-bar">
            <button class="power-btn" id="btnPower1" onclick="game.togglePowerUp('single')"><span>TEK BLOK SİL</span><span style="color:var(--gold)">150</span></button>
            <button class="power-btn" id="btnPower2" onclick="game.togglePowerUp('cross')"><span>SATIR SİL</span><span style="color:var(--gold)">500</span></button>
            <button class="power-btn" id="btnPower3" onclick="game.togglePowerUp('nuke')"><span>FULL TEMİZLE</span><span style="color:var(--gold)">1000</span></button>
        </div>
        <div class="dock" id="dock">
            <div class="slot" id="slot0" onmousedown="game.handleSlotTouch(event, 0)" ontouchstart="game.handleSlotTouch(event, 0)"></div>
            <div class="slot" id="slot1" onmousedown="game.handleSlotTouch(event, 1)" ontouchstart="game.handleSlotTouch(event, 1)"></div>
            <div class="slot" id="slot2" onmousedown="game.handleSlotTouch(event, 2)" ontouchstart="game.handleSlotTouch(event, 2)"></div>
        </div>
    </div>

    <div class="overlay" id="overlay">
        <h2 style="color:var(--danger); font-size: 3rem; margin:0">OYUN BİTTİ</h2>
        <p>SKOR: <span id="finalScore">0</span></p>
        <button class="btn-restart" onclick="game.resetGame()">TEKRAR DENE</button>
    </div>

    <script>
        const GRID_SIZE = 8;
        const OFFSET_Y = 120; 

        const SHAPES = [
            [[1]], [[1,1]], [[1,1,1]], [[1,1,1,1]],
            [[1,1],[1,1]], [[1,1,1],[0,1,0]], [[1,0],[1,0],[1,1]],
            [[0,1],[0,1],[1,1]], [[1,1,0],[0,1,1]]
        ];
        const COLORS = ['#f39c12', '#e74c3c', '#8e44ad', '#3498db', '#2ecc71'];

        class Game {
            constructor() {
                this.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
                this.score = 0;
                this.coins = JSON.parse(localStorage.getItem('zenSave_v6')) || 0;
                this.currentShapes = [null, null, null];
                this.draggedShape = null;
                this.activePowerUp = null;
                this.cellSize = 0;
                this.gridEl = document.getElementById('grid');
                this.init();
            }

            init() {
                this.renderGrid();
                this.updateUI();
                this.spawnShapes();
                
                setTimeout(() => {
                    this.cellSize = this.gridEl.children[0].offsetWidth;
                    document.documentElement.style.setProperty('--drag-size', this.cellSize + 'px');
                }, 100);

                window.addEventListener('mousemove', e => this.onMove(e));
                window.addEventListener('touchmove', e => this.onMove(e), { passive: false });
                window.addEventListener('mouseup', e => this.endDrag(e));
                window.addEventListener('touchend', e => this.endDrag(e));
            }

            save() { localStorage.setItem('zenSave_v6', JSON.stringify(this.coins)); }

            renderGrid() {
                this.gridEl.innerHTML = '';
                for(let i=0; i<64; i++) {
                    const c = document.createElement('div');
                    c.className = 'cell';
                    c.onclick = () => this.handlePower(Math.floor(i/8), i%8);
                    this.gridEl.appendChild(c);
                }
            }

            updateUI() {
                document.getElementById('uiScore').innerText = this.score;
                document.getElementById('uiCoins').innerText = this.coins;
                const costs = {single:150, cross:500, nuke:1000};
                ['single','cross','nuke'].forEach((type, idx) => {
                    const b = document.getElementById('btnPower' + (idx+1));
                    b.disabled = this.coins < costs[type];
                    b.classList.toggle('active-mode', this.activePowerUp === type);
                });
            }

            spawnShapes() {
                for(let i=0; i<3; i++) {
                    if(!this.currentShapes[i]) {
                        const m = SHAPES[Math.floor(Math.random()*SHAPES.length)];
                        const c = COLORS[Math.floor(Math.random()*COLORS.length)];
                        this.currentShapes[i] = { matrix: m, color: c };
                        this.renderSlot(i, m, c);
                    }
                }
                if(this.isGameOver()) document.getElementById('overlay').classList.add('active');
            }

            renderSlot(idx, m, color) {
                const slot = document.getElementById('slot'+idx);
                slot.innerHTML = '';
                const wrap = document.createElement('div');
                wrap.className = 'shape-preview';
                wrap.id = 'preview-' + idx;
                wrap.style.gridTemplateColumns = `repeat(${m[0].length}, 1fr)`;
                
                m.forEach((row, rIdx) => row.forEach((val, cIdx) => {
                    const b = document.createElement('div');
                    if(val) { b.className = 'shape-block'; b.style.backgroundColor = color; } 
                    else { b.style.width='22px'; b.style.height='22px'; }
                    wrap.appendChild(b);
                }));
                slot.appendChild(wrap);
            }

            // Slota dokunulduğunda bloğu kolayca al
            handleSlotTouch(e, idx) {
                if(this.activePowerUp || !this.currentShapes[idx]) return;
                e.preventDefault();
                const preview = document.getElementById('preview-'+idx);
                this.startDrag(e, preview, idx);
            }

            startDrag(e, el, idx) {
                const t = e.touches ? e.touches[0] : e;
                const rect = el.getBoundingClientRect();
                
                // Pivot hesabı (Tutulan yeri belirleme)
                let pivotC = 0, pivotR = 0;
                if(this.currentShapes[idx]) {
                    const m = this.currentShapes[idx].matrix;
                    pivotC = Math.floor(m[0].length / 2);
                    pivotR = Math.floor(m.length / 2);
                }

                this.draggedShape = {
                    el, idx, data: this.currentShapes[idx], parent: el.parentNode,
                    pivotR, pivotC
                };

                el.classList.add('dragging');
                document.body.appendChild(el);
                this.moveEl(t.clientX, t.clientY);
            }

            onMove(e) {
                if(!this.draggedShape) return;
                e.preventDefault();
                const t = e.touches ? e.touches[0] : e;
                this.moveEl(t.clientX, t.clientY);

                this.clearGhost();
                const pos = this.getGridPos(t.clientX, t.clientY - OFFSET_Y);
                if(pos) {
                    const startR = pos.r - this.draggedShape.pivotR;
                    const startC = pos.c - this.draggedShape.pivotC;
                    if(this.canPlace(this.draggedShape.data.matrix, startR, startC)) {
                        this.drawGhost(this.draggedShape.data.matrix, startR, startC);
                    }
                }
            }

            moveEl(x, y) {
                const el = this.draggedShape.el;
                const blockSize = this.cellSize + 4;
                const left = x - (this.draggedShape.pivotC * blockSize) - (this.cellSize/2);
                const top = y - (this.draggedShape.pivotR * blockSize) - (this.cellSize/2) - OFFSET_Y;
                el.style.left = left + 'px';
                el.style.top = top + 'px';
            }

            endDrag(e) {
                if(!this.draggedShape) return;
                const t = e.changedTouches ? e.changedTouches[0] : e;
                const pos = this.getGridPos(t.clientX, t.clientY - OFFSET_Y);
                let placed = false;

                if(pos) {
                    const startR = pos.r - this.draggedShape.pivotR;
                    const startC = pos.c - this.draggedShape.pivotC;
                    if(this.canPlace(this.draggedShape.data.matrix, startR, startC)) {
                        this.placeShape(this.draggedShape.data, startR, startC);
                        this.currentShapes[this.draggedShape.idx] = null;
                        this.draggedShape.el.remove();
                        this.coins += this.draggedShape.data.matrix.flat().filter(x=>x).length * 5;
                        placed = true;
                        this.updateUI(); this.save();
                        if(this.currentShapes.every(x=>x===null)) this.spawnShapes();
                    }
                }

                if(!placed) {
                    this.draggedShape.el.classList.remove('dragging');
                    this.draggedShape.parent.appendChild(this.draggedShape.el);
                }
                
                this.clearGhost();
                this.draggedShape = null;
            }

            getGridPos(x, y) {
                const rect = this.gridEl.getBoundingClientRect();
                const c = Math.floor((x - rect.left) / (rect.width / 8));
                const r = Math.floor((y - rect.top) / (rect.height / 8));
                return (r >= 0 && r < 8 && c >= 0 && c < 8) ? {r,c} : null;
            }

            canPlace(m, r, c) {
                for(let i=0; i<m.length; i++) for(let j=0; j<m[i].length; j++) {
                    if(m[i][j]) {
                        if(r+i<0 || r+i>=8 || c+j<0 || c+j>=8 || this.grid[r+i][c+j]) return false;
                    }
                }
                return true;
            }

            placeShape(d, r, c) {
                d.matrix.forEach((row, i) => row.forEach((val, j) => {
                    if(val) this.grid[r+i][c+j] = d.color;
                }));
                this.refreshGrid();
                this.checkLines();
            }

            drawGhost(m, r, c) {
                m.forEach((row, i) => row.forEach((val, j) => {
                    if(val) this.gridEl.children[(r+i)*8+(c+j)].classList.add('ghost');
                }));
            }

            clearGhost() { document.querySelectorAll('.ghost').forEach(e=>e.classList.remove('ghost')); }

            refreshGrid() {
                for(let i=0; i<64; i++) {
                    const cell = this.gridEl.children[i];
                    const val = this.grid[Math.floor(i/8)][i%8];
                    cell.style.backgroundColor = val || 'var(--cell-empty)';
                    cell.classList.toggle('filled', !!val);
                }
            }

            checkLines() {
                let rL = [], cL = [];
                for(let r=0; r<8; r++) if(this.grid[r].every(x=>x)) rL.push(r);
                for(let c=0; c<8; c++) { let f=true; for(let r=0; r<8; r++) if(!this.grid[r][c]) f=false; if(f) cL.push(c); }
                
                if(rL.length + cL.length > 0) {
                    // SATIR BAŞI 100 PUAN
                    this.score += (rL.length + cL.length) * 100;
                    rL.forEach(r => this.grid[r].fill(null));
                    cL.forEach(c => { for(let r=0; r<8; r++) this.grid[r][c]=null; });
                    setTimeout(() => { this.refreshGrid(); this.updateUI(); }, 150);
                }
            }

            togglePowerUp(t) {
                this.activePowerUp = (this.activePowerUp === t) ? null : t;
                if(t === 'nuke' && this.activePowerUp) {
                    if(confirm('Tüm alanı temizle? (1000 Para)')) { this.grid = this.grid.map(r=>r.fill(null)); this.coins -= 1000; this.activePowerUp = null; this.refreshGrid(); this.updateUI(); this.save(); }
                    else this.activePowerUp = null;
                }
                this.updateUI();
            }

            handlePower(r, c) {
                if(!this.activePowerUp) return;
                if(this.activePowerUp === 'single') {
                    this.grid[r][c] = null;
                    this.coins -= 150;
                } else if(this.activePowerUp === 'cross') {
                    // SATIR VE SÜTUN SİLME
                    for(let i=0; i<8; i++) { this.grid[r][i] = null; this.grid[i][c] = null; }
                    this.coins -= 500;
                }
                this.activePowerUp = null;
                this.refreshGrid(); this.updateUI(); this.save();
            }

            isGameOver() {
                return this.currentShapes.filter(s=>s).every(s => {
                    for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(this.canPlace(s.matrix, r, c)) return false;
                    return true;
                });
            }

            resetGame() {
                this.score = 0; this.grid = this.grid.map(r=>r.fill(null));
                this.currentShapes = [null,null,null];
                document.getElementById('overlay').classList.remove('active');
                this.refreshGrid(); this.updateUI(); this.spawnShapes();
            }
        }

        const game = new Game();
    </script>
</body>
</html>
