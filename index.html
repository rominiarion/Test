<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Block Zen</title>
    <style>
        /* * AVANT-GARDE UI DESIGN SYSTEM
         * Intentional Minimalism & Dark Mode Optimization
         */
        :root {
            --bg-color: #0f1014;
            --grid-bg: #1a1c23;
            --cell-empty: #252830;
            --accent: #64ffda;
            --text-primary: #e6f1ff;
            --text-secondary: #8892b0;
            --glass: rgba(255, 255, 255, 0.05);
            --danger: #ff5555;
            
            /* Block Colors */
            --c1: #ff0055; /* Magenta */
            --c2: #00ff99; /* Green */
            --c3: #00ccff; /* Blue */
            --c4: #ffaa00; /* Orange */
            --c5: #aa00ff; /* Purple */
        }

        * {
            box-sizing: border-box;
            touch-action: none; /* Mobil kaydırmayı engeller */
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        /* UI HEADER */
        .header {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            margin-bottom: 10px;
        }

        .score-container {
            display: flex;
            flex-direction: column;
        }

        .score-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .score-value {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(to right, var(--accent), #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .best-score {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: right;
        }

        /* GAME BOARD */
        .game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            background: var(--grid-bg);
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
        }

        .cell {
            background-color: var(--cell-empty);
            border-radius: 4px;
            transition: background-color 0.2s, transform 0.1s;
        }

        .cell.filled {
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }

        /* ANIMATIONS */
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes flash {
            0% { filter: brightness(1); }
            50% { filter: brightness(2); background-color: white; }
            100% { filter: brightness(1); }
        }

        .cell.animate-clear {
            animation: flash 0.4s ease-out forwards;
        }

        /* SHAPE CONTAINER (BOTTOM) */
        .shapes-dock {
            width: 100%;
            max-width: 500px;
            height: 160px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 20px;
        }

        .shape-slot {
            width: 30%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* DRAGGABLE SHAPES */
        .shape-preview {
            display: grid;
            gap: 2px;
            pointer-events: auto; /* Sürükleme için */
            touch-action: none;
            transition: transform 0.1s;
        }

        .shape-block {
            width: 25px;
            height: 25px;
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* While Dragging */
        .shape-preview.dragging {
            position: fixed;
            z-index: 1000;
            opacity: 0.9;
            transform: scale(1.2);
            pointer-events: none; /* Alttaki gridi algılamak için */
        }

        /* GHOST PREVIEW ON GRID */
        .cell.ghost {
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px dashed rgba(255, 255, 255, 0.3);
        }

        /* OVERLAY / MODAL */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 16, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .overlay h2 {
            font-size: 3rem;
            margin: 0;
            background: linear-gradient(to right, var(--c1), var(--c4));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            margin-top: 30px;
            padding: 15px 40px;
            background: var(--accent);
            color: var(--bg-color);
            font-weight: bold;
            font-size: 1.2rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(100, 255, 218, 0.3);
            transition: transform 0.1s;
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* MOBILE ADJUSTMENTS */
        @media (max-width: 400px) {
            .shape-block { width: 20px; height: 20px; }
            .game-container { gap: 2px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="score-container">
            <span class="score-label">Skor</span>
            <span class="score-value" id="currentScore">0</span>
        </div>
        <div class="score-container">
            <span class="best-score" id="highScore">EN İYİ: 0</span>
        </div>
    </div>

    <div class="game-container" id="grid">
        </div>

    <div class="shapes-dock" id="dock">
        <div class="shape-slot" id="slot0"></div>
        <div class="shape-slot" id="slot1"></div>
        <div class="shape-slot" id="slot2"></div>
    </div>

    <div class="overlay" id="gameOverOverlay">
        <h2>OYUN BİTTİ</h2>
        <p style="color: var(--text-secondary); margin-top: 10px;">Skorun</p>
        <div class="score-value" id="finalScore">0</div>
        <button class="btn" onclick="game.resetGame()">TEKRAR OYNA</button>
    </div>

    <script>
        /**
         * SENIOR ARCHITECTURAL LOGIC
         * State Management, Sound Synthesis, Grid Physics
         */
        
        // --- SOUND ENGINE (Web Audio API) ---
        // Dış dosya bağımlılığı olmadan prosedürel ses üretimi.
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const SoundEngine = {
            playTone: (freq, type, duration, vol = 0.1) => {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            
            pickup: () => SoundEngine.playTone(440, 'sine', 0.1, 0.05),
            drop: () => SoundEngine.playTone(300, 'triangle', 0.2, 0.1),
            invalid: () => {
                SoundEngine.playTone(150, 'sawtooth', 0.1, 0.05);
                setTimeout(() => SoundEngine.playTone(100, 'sawtooth', 0.1, 0.05), 100);
            },
            clear: (combo) => {
                // Combo sayısına göre artan akor
                const base = 500 + (combo * 100);
                SoundEngine.playTone(base, 'sine', 0.3, 0.1);
                setTimeout(() => SoundEngine.playTone(base * 1.5, 'sine', 0.4, 0.1), 50);
                setTimeout(() => SoundEngine.playTone(base * 2, 'sine', 0.5, 0.05), 100);
            },
            gameOver: () => {
                SoundEngine.playTone(200, 'sawtooth', 1.0, 0.2);
                setTimeout(() => SoundEngine.playTone(150, 'sawtooth', 1.0, 0.2), 300);
            }
        };

        // --- GAME CONSTANTS & CONFIG ---
        const GRID_SIZE = 8;
        const CELL_GAP = 4;
        const COLORS = [
            'var(--c1)', 'var(--c2)', 'var(--c3)', 'var(--c4)', 'var(--c5)'
        ];

        // Tetromino & Custom Shapes Definitions (Matrix representation)
        const SHAPES = [
            [[1]], // Dot
            [[1, 1]], // 2-Line H
            [[1], [1]], // 2-Line V
            [[1, 1, 1]], // 3-Line H
            [[1], [1], [1]], // 3-Line V
            [[1, 1, 1, 1]], // 4-Line H
            [[1], [1], [1], [1]], // 4-Line V
            [[1, 1], [1, 1]], // Square
            [[1, 0], [1, 0], [1, 1]], // L
            [[0, 1], [0, 1], [1, 1]], // Reverse L
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1, 0], [0, 1, 1]], // Z
        ];

        // --- CORE GAME CLASS ---
        class Game {
            constructor() {
                this.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
                this.score = 0;
                this.highScore = localStorage.getItem('blockZenHigh') || 0;
                this.draggedShape = null;
                this.dragOrigin = { x: 0, y: 0 };
                this.dragOffset = { x: 0, y: 0 };
                this.currentShapes = [null, null, null];
                
                // DOM Elements
                this.gridEl = document.getElementById('grid');
                this.scoreEl = document.getElementById('currentScore');
                this.highScoreEl = document.getElementById('highScore');
                this.overlay = document.getElementById('gameOverOverlay');
                this.finalScoreEl = document.getElementById('finalScore');
                
                this.init();
            }

            init() {
                this.renderGrid();
                this.updateScore(0);
                this.highScoreEl.innerText = `EN İYİ: ${this.highScore}`;
                this.spawnShapes();
                
                // Global Events for releasing drag anywhere
                window.addEventListener('mouseup', (e) => this.handleDragEnd(e));
                window.addEventListener('touchend', (e) => this.handleDragEnd(e));
                window.addEventListener('mousemove', (e) => this.handleDragMove(e));
                window.addEventListener('touchmove', (e) => this.handleDragMove(e), { passive: false });
            }

            renderGrid() {
                this.gridEl.innerHTML = '';
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        // Calculate size dynamically
                        this.gridEl.appendChild(cell);
                    }
                }
            }

            spawnShapes() {
                for (let i = 0; i < 3; i++) {
                    if (!this.currentShapes[i]) {
                        const shapeData = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                        const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                        this.createShapeElement(i, shapeData, color);
                        this.currentShapes[i] = { matrix: shapeData, color: color };
                    }
                }
                if (this.checkGameOver()) {
                    this.triggerGameOver();
                }
            }

            createShapeElement(slotIndex, matrix, color) {
                const slot = document.getElementById(`slot${slotIndex}`);
                slot.innerHTML = '';
                
                const wrapper = document.createElement('div');
                wrapper.className = 'shape-preview';
                wrapper.style.gridTemplateColumns = `repeat(${matrix[0].length}, 1fr)`;
                wrapper.dataset.slot = slotIndex;
                
                // Generate blocks
                matrix.forEach(row => {
                    row.forEach(val => {
                        const block = document.createElement('div');
                        if (val === 1) {
                            block.className = 'shape-block';
                            block.style.backgroundColor = color;
                        } else {
                            block.style.width = '25px'; // Spacer
                            block.style.height = '25px';
                        }
                        wrapper.appendChild(block);
                    });
                });

                // Event Listeners for dragging
                const startDrag = (e) => this.handleDragStart(e, wrapper, slotIndex);
                wrapper.addEventListener('mousedown', startDrag);
                wrapper.addEventListener('touchstart', startDrag, { passive: false });
                
                slot.appendChild(wrapper);
            }

            handleDragStart(e, el, index) {
                e.preventDefault();
                SoundEngine.pickup();
                
                this.draggedShape = {
                    el: el,
                    index: index,
                    data: this.currentShapes[index],
                    originalParent: el.parentNode,
                    startX: el.getBoundingClientRect().left,
                    startY: el.getBoundingClientRect().top
                };

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                // Center logic
                const rect = el.getBoundingClientRect();
                this.dragOffset.x = clientX - rect.left - (rect.width / 2); // Center drag
                this.dragOffset.y = clientY - rect.top - (rect.height / 2); // Center drag

                el.classList.add('dragging');
                document.body.appendChild(el); // Move to body to float freely
                
                this.moveElement(clientX, clientY);
            }

            handleDragMove(e) {
                if (!this.draggedShape) return;
                e.preventDefault(); // Prevent scroll on mobile

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                this.moveElement(clientX, clientY);
                this.checkGhost(clientX, clientY);
            }

            moveElement(x, y) {
                const el = this.draggedShape.el;
                el.style.left = `${x - (el.offsetWidth/2)}px`;
                el.style.top = `${y - (el.offsetHeight*1.5)}px`; // Finger offset for visibility
            }

            handleDragEnd(e) {
                if (!this.draggedShape) return;
                
                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

                // Check drop
                const dropPos = this.getGridPos(clientX, clientY - 80); // Offset compensation
                
                if (dropPos && this.canPlace(this.draggedShape.data.matrix, dropPos.r, dropPos.c)) {
                    this.placeShape(this.draggedShape.data, dropPos.r, dropPos.c);
                    this.currentShapes[this.draggedShape.index] = null; // Remove from logical hand
                    this.draggedShape.el.remove(); // Remove DOM
                    SoundEngine.drop();
                    
                    // Respawn if hand empty
                    if (this.currentShapes.every(s => s === null)) {
                        setTimeout(() => this.spawnShapes(), 300);
                    }
                } else {
                    // Return to dock
                    SoundEngine.invalid();
                    this.draggedShape.el.classList.remove('dragging');
                    this.draggedShape.el.style.left = '';
                    this.draggedShape.el.style.top = '';
                    this.draggedShape.originalParent.appendChild(this.draggedShape.el);
                }

                this.clearGhost();
                this.draggedShape = null;
            }

            getGridPos(x, y) {
                const gridRect = this.gridEl.getBoundingClientRect();
                
                // Check bounds
                if (x < gridRect.left || x > gridRect.right || y < gridRect.top || y > gridRect.bottom) {
                    return null;
                }

                const cellSize = gridRect.width / GRID_SIZE;
                const c = Math.floor((x - gridRect.left) / cellSize);
                const r = Math.floor((y - gridRect.top) / cellSize);

                return { r, c };
            }

            canPlace(matrix, r, c) {
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[i].length; j++) {
                        if (matrix[i][j] === 1) {
                            const newR = r + i;
                            const newC = c + j;
                            if (newR >= GRID_SIZE || newC >= GRID_SIZE || this.grid[newR][newC] !== null) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            placeShape(shapeData, r, c) {
                const matrix = shapeData.matrix;
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[i].length; j++) {
                        if (matrix[i][j] === 1) {
                            this.grid[r + i][c + j] = shapeData.color;
                            this.updateCell(r + i, c + j, shapeData.color);
                        }
                    }
                }
                
                this.addScore(matrix.flat().filter(x=>x===1).length);
                this.checkLines();
                
                // Check Game Over after placement and line clear
                setTimeout(() => {
                   if (this.currentShapes.some(s => s !== null) && this.checkGameOver()) {
                       this.triggerGameOver();
                   }
                }, 500);
            }

            updateCell(r, c, color) {
                const idx = r * GRID_SIZE + c;
                const cell = this.gridEl.children[idx];
                cell.style.backgroundColor = color || 'var(--cell-empty)';
                if (color) {
                    cell.classList.add('filled');
                    cell.style.animation = 'popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                } else {
                    cell.classList.remove('filled');
                    cell.style.animation = '';
                }
            }

            checkGhost(x, y) {
                this.clearGhost();
                const pos = this.getGridPos(x, y - 80); // Offset matches drag handle
                if (pos && this.canPlace(this.draggedShape.data.matrix, pos.r, pos.c)) {
                    const matrix = this.draggedShape.data.matrix;
                    for (let i = 0; i < matrix.length; i++) {
                        for (let j = 0; j < matrix[i].length; j++) {
                            if (matrix[i][j] === 1) {
                                const idx = (pos.r + i) * GRID_SIZE + (pos.c + j);
                                this.gridEl.children[idx].classList.add('ghost');
                            }
                        }
                    }
                }
            }

            clearGhost() {
                const ghosts = document.querySelectorAll('.ghost');
                ghosts.forEach(el => el.classList.remove('ghost'));
            }

            checkLines() {
                let linesCleared = 0;
                let rowsToClear = [];
                let colsToClear = [];

                // Check Rows
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (this.grid[r].every(val => val !== null)) rowsToClear.push(r);
                }
                // Check Cols
                for (let c = 0; c < GRID_SIZE; c++) {
                    let full = true;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        if (this.grid[r][c] === null) full = false;
                    }
                    if (full) colsToClear.push(c);
                }

                if (rowsToClear.length === 0 && colsToClear.length === 0) return;

                // Animation & Logic
                linesCleared = rowsToClear.length + colsToClear.length;
                SoundEngine.clear(linesCleared);

                const clearCells = () => {
                    rowsToClear.forEach(r => {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            this.grid[r][c] = null;
                            const el = this.gridEl.children[r * GRID_SIZE + c];
                            el.classList.add('animate-clear');
                        }
                    });
                    colsToClear.forEach(c => {
                        for (let r = 0; r < GRID_SIZE; r++) {
                            this.grid[r][c] = null;
                            const el = this.gridEl.children[r * GRID_SIZE + c];
                            el.classList.add('animate-clear');
                        }
                    });

                    // Cleanup visuals after animation
                    setTimeout(() => {
                        for (let r = 0; r < GRID_SIZE; r++) {
                            for (let c = 0; c < GRID_SIZE; c++) {
                                this.updateCell(r, c, this.grid[r][c]);
                                const el = this.gridEl.children[r * GRID_SIZE + c];
                                el.classList.remove('animate-clear');
                            }
                        }
                    }, 400);
                };

                clearCells();
                this.addScore(linesCleared * 10 + (linesCleared > 1 ? linesCleared * 20 : 0)); // Bonus for combo
            }

            checkGameOver() {
                // If hand is empty, not game over
                const availableShapes = this.currentShapes.filter(s => s !== null);
                if (availableShapes.length === 0) return false;

                // Check if ANY shape can fit ANYWHERE
                for (let s = 0; s < availableShapes.length; s++) {
                    const matrix = availableShapes[s].matrix;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (this.canPlace(matrix, r, c)) return false; // Found a spot
                        }
                    }
                }
                return true; // No spots found
            }

            triggerGameOver() {
                SoundEngine.gameOver();
                this.overlay.classList.add('active');
                this.finalScoreEl.innerText = this.score;
            }

            resetGame() {
                this.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
                this.score = 0;
                this.updateScore(0);
                this.overlay.classList.remove('active');
                this.renderGrid();
                this.currentShapes = [null, null, null];
                this.spawnShapes();
            }

            addScore(amount) {
                this.score += amount;
                this.updateScore(this.score);
            }

            updateScore(val) {
                this.scoreEl.innerText = val;
                if (val > this.highScore) {
                    this.highScore = val;
                    localStorage.setItem('blockZenHigh', this.highScore);
                    this.highScoreEl.innerText = `EN İYİ: ${this.highScore}`;
                }
            }
        }

        // Start Game
        const game = new Game();

    </script>
</body>
</html>
